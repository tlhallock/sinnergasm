use sinnergasm::protos as msg;
use ui_common::events::UiEvent;

use rdev;

// TODO: there is a grab feature, maybe the prison is not needed!

#[derive(Default)]
pub(crate) struct MouseTracker {
  last_position: Option<(f64, f64)>,
}

impl MouseTracker {
  pub(crate) fn listen(&mut self, event: UiEvent) {
    if let UiEvent::ControlEvent(rdev::EventType::MouseMove { x, y }) = event {
      self.last_position = Some((x, y));
    }
  }
}

#[derive(Debug)]
pub(crate) struct MouseParoleOfficer {
  initial_position: (f64, f64),
  last_position: (f64, f64),
  current_offset: (f64, f64),
}

impl MouseParoleOfficer {
  pub(crate) fn new(initial_position: (f64, f64)) -> Self {
    Self {
      initial_position,
      last_position: initial_position,
      current_offset: (0.0, 0.0),
    }
  }

  pub(crate) fn patch(
    &mut self,
    (x, y): (f64, f64),
  ) -> Option<msg::MouseMoveEvent> {
    println!("State: {:?} received event {:?}", self, (x, y));
    if x == self.initial_position.0 && y == self.initial_position.1 {
      println!("Ignoring event back to initial position");
      // Ignore the events we create
      self.last_position = (x, y);
      return None;
    } else {
      println!(
        "Event not back to initial position, must be generated by user."
      );
    }

    let delta_x = x - self.last_position.0;
    let delta_y = y - self.last_position.1;
    self.last_position = (x, y);

    self.current_offset =
      (self.current_offset.0 + delta_x, self.current_offset.1 + delta_y);
    let message = msg::MouseMoveEvent { delta_x, delta_y, };
    if let Err(err) = rdev::simulate(&rdev::EventType::MouseMove {
      x: self.initial_position.0,
      y: self.initial_position.1,
    }) {
      println!("Failed to simulate mouse move: {:?}", err);
    }
    Some(message)
  }
}

// if let ControlEvent::RDevEvent(rdev::EventType::MouseMove { x, y }) = event {
//   self.last_position = Some((x, y));
//   if self.lock_mouse && self.required_position.is_some() {
//     self.required_position = Some((x, y));
//   }
// }
// if matches!(event, ControlEvent::StartListening) {
//   if self.last_position.is_none() {
//     println!("No mouse position found, ignoring listen event");
//     return;
//   }
//   self.required_position = self.last_position;
//   self.virtual_location = self.last_position;
// }
// fn lock_mouse(
//   receiver: mpsc::Receiver<ControlEvent>,
//   sender: mpsc::Sender<ControlEvent>,
// ) {
//   let mut current_mouse_pos = (0, 0);

//   while let Ok(event) = receiver.recv() {
//     match event {
//       ControlEvent::StartListening => {
//         println!("Start listening");
//       }
//       _ => {}
//     }
//     if let Err(err) = sender.send(event) {
//       println!("Failed to send event to listener: {:?}", err);
//     }
//   }
// }
